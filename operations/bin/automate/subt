#!/usr/bin/env bash

# load header helper functions
. "$SUBT_PATH/operations/bin/.header.bash"
. "$SUBT_PATH/operations/bin/automate/.header.bash"
. "$SUBT_PATH/operations/bin/automate/cmpl/.auto_completion.bash"

if [ ! -z "$ZSH_NAME" ]; then
  # bash-completion under zsh
  autoload bashcompinit
  bashcompinit

  autoload -Uz compinit
  compinit

  # remove fuzzy search in zsh-completion
  zstyle ":completion:*" matcher-list ''
fi

# @brief evaluate which subcommand to switch and execute
__subt_git_execute() {
  # TODO: check if has -p or -v for preview and verbose
  local _opts=""
  chk_flag -p $@ && _opts="$_opts -p"
  chk_flag -v $@ && _opts="$_opts -v"

  if chk_flag clone $@; then
    shift 2
    for cmd in "$@"; do
      chk_flag -p $cmd || chk_flag -v $cmd && continue
      _run_deployer "clone.$cmd" "$_opts"
    done

  elif chk_flag reset $@; then
    shift 2
    for cmd in "$@"; do
      chk_flag -p $cmd || chk_flag -v $cmd && continue
      _run_deployer "rm.$cmd" "$_opts"
      _run_deployer "clone.$cmd" "$_opts"
    done

  elif chk_flag rm $@; then
    shift 2
    for cmd in "$@"; do
      chk_flag -p $cmd || chk_flag -v $cmd && continue
      _run_deployer "rm.$cmd" "$_opts"
    done

  elif chk_flag clean $@; then
    shift 2
    for cmd in "$@"; do
      chk_flag -p $cmd || chk_flag -v $cmd && continue
      _run_deployer "clean.$cmd" "$_opts"
    done

  elif chk_flag pull $@; then
    shift 2
    for cmd in "$@"; do
      chk_flag -p $cmd || chk_flag -v $cmd && continue
      _run_deployer "pull.$cmd" "$_opts"
    done

  elif chk_flag ignore $@; then
    shift 2
    for cmd in "$@"; do
      chk_flag -p $cmd || chk_flag -v $cmd && continue
      _run_deployer "ignore.$cmd" "$_opts"
    done

  elif chk_flag unignore $@; then
    shift 2
    for cmd in "$@"; do
      chk_flag -p $cmd || chk_flag -v $cmd && continue
      _run_deployer "unignore.$cmd" "$_opts"
    done

  elif chk_flag status $@ || chk_flag sync $@  || chk_flag add $@; then
    shift 1
    ($GL_BIN_AUTOMATE_DIR/cmpl/git.bash $@)

  elif chk_flag help $@; then
    __git_help
  fi
}

# @brief evaluate which subcommand to switch and execute
__subt_cloud_execute() {
  # ansible azure install
  if chk_flag ansible $@; then
    shift 2 # shift the 'git', 'info' tokens
    (subtani_install.sh $@)
  # terraform azure setup
  elif chk_flag terraform $@; then
    shift 2 # shift the 'cloud terraform' tokens
    if chk_flag init $@; then
      shift # shift the subcommand
      (subtf_init.sh $@)
    elif chk_flag cert $@; then
      shift # shift the subcommand
      (subtf_cert.sh $@)
    elif chk_flag plan $@; then
      shift # shift the subcommand
      (subtf_plan.sh $@)
    elif chk_flag apply $@; then
      shift # shift the subcommand
      (subtf_apply.sh $@)
    elif chk_flag mkvpn $@; then
      shift # shift the subcommand
      (subtf_mkvpn.sh $@)
    elif chk_flag rmvpn $@; then
      shift # shift the subcommand
      (subtf_rmvpn.sh $@)
    elif chk_flag start $@; then
      shift # shift the subcommand
      (subtf_start.sh $@)
    elif chk_flag stop $@; then
      shift # shift the subcommand
      (subtf_stop.sh $@)
    elif chk_flag destroy $@; then
      shift # shift the subcommand
      (subtf_destroy.sh $@)
    elif chk_flag monitor $@; then
      shift # shift the subcommand
      (subtf_monitor.sh $@)
    elif chk_flag env $@; then
      shift # shift the subcommand
      (install-terraform-current.sh $@)
    fi
  fi
}

# @brief evaluate which subcommand to switch and execute
__subt_tools_execute() {

  if chk_flag ssh $@; then
    shift 2 # shift the 'tools', 'ssh' tokens
    (subtu_avail_ssh $@)

  elif chk_flag teamviewer $@; then
    shift 2 # shift the 'tools', 'teamviewer' tokens
    (subtu_avail_teamviewer $@)

  elif chk_flag rdp $@; then
    shift 2 # shift the 'tools', 'teamviewer' tokens
    (subtu_azure_rdp $@)

  elif chk_flag snapshot $@; then
    shift 2 # shift the 'tools', 'snapshot' tokens
    (subtu_snapshot $@)
  fi
}

# //////////////////////////////////////////////////////////////////////////////
# @brief 'git subt' wrapper entrypoint
# //////////////////////////////////////////////////////////////////////////////
subt() {
  # get the current directory
  local __pwd=$(pwd)

  # execute actual git command (filter any 'git subt' subcommands)
  if chk_nth_flag 1 "git" "$@"; then
    # execute git subt main entrypoint
    __subt_git_execute $@
    # command git "$@"

  # execute 'git subt' subcommand
  elif chk_nth_flag 1 "deployer" "$@"; then
    shift 1 # shift 'deployer'
     _run_deployer "$@"

  elif chk_nth_flag 1 "cloud" "$@"; then
    __subt_cloud_execute $@

  elif chk_nth_flag 1 "tools" "$@"; then
    __subt_tools_execute $@

  elif chk_nth_flag 1 "update" "$@"; then
    cd $SUBT_PATH
    ./install-deployer.bash --uninstall
    ./install-deployer.bash --install
    text "Please source your bash or zsh rc: 'source ~/.bashrc'"

  elif chk_flag --help $@ || chk_flag help $@ || chk_flag -h $@; then
    __subt_help
    return 0
  fi

  # return to path of call
  cd $__pwd
}

# enable tab autocompletion
# 'nosort' option does not work with bash <= 4.4.20 (https://lists.defectivebydesign.org/archive/html/bug-bash/2017-05/msg00034.html)
complete -o nospace -o nosort -F _ac_subt_completion subt
