#!/usr/bin/env bash
# //////////////////////////////////////////////////////////////////////////////
# display usage
usage_msg="\
Usage: $(basename $0)

  options:
  --clean
      Removes all logfiles operations/field_testing/*.log

  == Snapshot Log Field Testing ==

  Create a snapshot log of all deploy repo's submodules.
    - logfile as operations/field_testing/snapshot-[current date].log
    - logfile contents of format: [submodule commit hash] [submodule deploy relative path]

For more help, please see the README.md or wiki."

# //////////////////////////////////////////////////////////////////////////////
# load helper scripts

# load print-info
. "$(dirname $0)/.utils.bash"
validate "load utils failed"

# load args
. "$(dirname $0)/args/.snapshot-field-testing-log-args.bash"
validate "load args failed"

# display usage message
is_display_usage "$usage_msg"

# get the directory of this script -- "build.bash"
script_path="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null && pwd )"
pushd $script_path  # go so script path

# //////////////////////////////////////////////////////////////////////////////
# script
script_title "Snapshot Field Testing Log"

# get all the submodules in the current directory
function get_all_submodules() {
  local result=$(git config --file .gitmodules --get-regexp path | awk '{ print $2 }')
  echo $result
}

# traverse through all the submodules in the given source directory
function traverse() {
  # find all the submodules in the current path level
  submodules=$(get_all_submodules $1)
  logfile=$2

  # recursive traverse for found submodules
  for submodule in $submodules
  do
    # print warning & ignore if directory does not exist
    if [ ! -d "$submodule" ]; then
      print_warning "Submodule $submodule does not exist.
      - Ignoring submodule in snapshot log.
      - Submodule is either not cloned or .gitmodules is incorrect.
      - Correct (if necessary) .gitmodules at '$(pwd)'\n"
    else
      # get submodule git information
      pushd $submodule
      local snapshot_submodule=$(realpath --relative-to="$SUBT_PATH" "$(pwd)")
      local snapshot_commit_hash=$(git rev-parse --verify HEAD)
      # recursive traverse, for any nested submodules
      traverse "$(pwd)" "$logfile"
      popd
      # write the `(commit hash) (submodule path)` to logfile
      echo "$snapshot_commit_hash $snapshot_submodule" >> $logfile
    fi

  done
}

# get the current date as yyyy-mm-dd HH:MM
function get_current_date() {
  local date=$(date '+%YY-%mM-%dD-%HH-%MM')
  echo $date
}

# //////////////////////////////////////////////////////////////////////////////
# create snapshot log file
function snapshot() {
  # create log file
  logfile="$SUBT_PATH/operations/field_testing/snapshot-$(get_current_date).log"
  touch $logfile
  display_text "Creating logfile: $logfile"

  # traverse submodules
  pushd $SUBT_PATH
  traverse "$SUBT_PATH" "$logfile"
  popd
}

# clean all snapshot log files
function clean() {
  if [ "$(find $SUBT_PATH/operations/field_testing/ -prune -empty  2>/dev/null)" ]
  then
    display_text "Nothing to clean."
  else
    display_text "Clean logfiles in: $SUBT_PATH/operations/field_testing/"
    rm $SUBT_PATH/operations/field_testing/*
  fi
}

# create snapshot log or clean all snapshot logs
if [ "$clean" = true ] ; then
  clean
else
  snapshot
fi

# //////////////////////////////////////////////////////////////////////////////
# cleanup & exit
popd
exit_success
