####################################################################################################
# robot 2 configuration file
- r1:
####################################################################################################

  ##################################################################################################
  - planning-pc:
  ##################################################################################################
    - 'export YELLOW="\033[1;33m"'
    - 'export BLUE="\033[1;36m"'
    - 'export RESET="\033[0m"'

    ################################################################################################
    # copy deploy repo from basestation to r1.planning-pc
    - transfer:
    ################################################################################################
      
      ### == user can modify ==
      # testing setp

      # connections
      - 'export host=planning-pc'
      - 'export user=robot'
  
      # paths
      - 'export LOCAL_DEPLOY_PATH=/home/$USER/deploy_ws/src'
      - 'export REMOTE_DEPLOY_PATH=/home/$user/deploy_ws/'
      
      # rsync options
      - 'export copy_opts="-avzh --delete --exclude=src/perception --exclude=src/state_estimation --exclude=src/launch/ugv_setup/logging/planning-pc/bags -e \"ssh -i $HOME/.ssh/deploy\" " ' 
      # rsync commands
      - export copy_to="rsync $copy_opts $LOCAL_DEPLOY_PATH $user@$host:$REMOTE_DEPLOY_PATH "
      - export copy_from="rsync $copy_opts $user@$host:$REMOTE_DEPLOY_PATH $LOCAL_DEPLOY_PATH "

      ### == user can modify done. ==

      ####################################################
      # perform actual transfer. do not change.
      ####################################################
      - print:
        # print
        - echo -e "\n${YELLOW}\t local deploy path -> \t $LOCAL_DEPLOY_PATH \n" ;
        - echo -e "\n${YELLOW}\t remote deploy path -> \t $REMOTE_DEPLOY_PATH \n" ;
        - echo -e "\n${YELLOW}\t host -> \t $host \n" ;
        - echo -e "\n${YELLOW}\t username -> \t $user \n" ;
        - echo -e "\n${YELLOW}\t transfer to -> \t $copy_to \n" ;

      - transfer:
        - echo -e "\n${YELLOW}\t local deploy path -> \t $LOCAL_DEPLOY_PATH \n" ;
        - echo -e "\n${YELLOW}\t remote deploy path -> \t $REMOTE_DEPLOY_PATH \n" ;
        - echo -e "\n${YELLOW}\t host -> \t $host \n" ;
        - echo -e "\n${YELLOW}\t username -> \t $user \n" ;

        # transfer TO remote host
        - to:
          # create the remote directory
          - ssh $user@$host -i ~/.ssh/deploy "mkdir -p $REMOTE_DEPLOY_PATH"

          # copy command
          - 'export copy_cmd=$copy_to'

        # transfer FROM remote host
        - from:
          - 'export copy_cmd=$copy_from'

        # evaluate copy
        - echo -e "\n${YELLOW}\t copy command -> \t $copy_cmd \n"
        - eval $copy_cmd
      
      # delete remote deploy workspace
      - delete:
        - ssh $user@$host "rm -rf $REMOTE_DEPLOY_PATH"

    ################################################################################################
    - docker:
    ################################################################################################
      - +ssh:{ robot:planning-pc:/home/$USER/.ssh/deploy }

      ####################################################
      # setup
      ####################################################
      - hostname
      - whoami
      - pwd
      
      ####################################################
      # path setup
      - 'export DEPLOY_WS=/home/$(whoami)/deploy_ws/'
      - 'export DEPLOY_SRC=/home/$(whoami)/deploy_ws/src/'
      - 'export DOCKER_CONFIG=field/robot/planning-pc'
      - 'export DOCKER_CONFIG_PATH=docker/env'
      
      ####################################################
      # print docker configuration information
      ####################################################
      - print:
        - echo -e "\n${BLUE} == Docker images to create == \n" ;
        - echo -e "\n${YELLOW}\tenv -> \t $DOCKER_CONFIG_PATH/osrf/ros.config \n" ;
        - echo -e "\n${YELLOW}\tenv -> \t $DOCKER_CONFIG_PATH/osrf/osrf.config \n" ;
        - echo -e "\n${YELLOW}\tenv -> \t $DOCKER_CONFIG_PATH/subt/ros.config \n" ;
        - echo -e "\n${YELLOW}\tenv -> \t $DOCKER_CONFIG_PATH/field/robot/planning-pc.config \n" ;
        - echo -e "\n${YELLOW} ** Remember to always transfer any changed configuration files! ** \n";
        - echo -e "\n${YELLOW}\t env -> \t $DOCKER_CONFIG \n" ;
        - echo -e "\n${YELLOW}\t env -> \t $DOCKER_CONFIG_PATH/subt/subt.config \n" ;
        - echo -e "\n${YELLOW}\t subt remote env filepath -> \t $DEPLOY_SRC/$DOCKER_CONFIG_PATH/$DOCKER_CONFIG.config \n"
        - while IFS= read line;
          do 
            echo -e ${BLUE} "\t$line";
          done < "$DEPLOY_SRC/$DOCKER_CONFIG_PATH/$DOCKER_CONFIG.config"

      ####################################################
      # build docker images
      ####################################################
      - cd $DEPLOY_SRC/docker/scripts
      - image:
        - 'export BUILD_ARGS="--force" '
        - osrf:
          - echo $LANG
          - ./build.bash --env local/osrf/ros $BUILD_ARGS
          - ./build.bash --env local/osrf/osrf $BUILD_ARGS
        - subt:
          - ./build.bash --env local/subt/ros $BUILD_ARGS
          - ./build.bash --env field/robot/planning-pc $BUILD_ARGS

      ####################################################
      # start docker images
      ####################################################
      - start:
        - 'export START_ARGS=" --no-nvidia " '
        - ./run.bash --env field/robot/planning-pc $START_ARGS

      ####################################################
      # stop docker images
      ####################################################
      - stop:
        - 'export STOP_ARGS="--stop --containers " '
        - ./clean.bash --env field/robot/planning-pc $STOP_ARGS
      
      - remove:
        - 'export STOP_ARGS="--remove --containers " '
        - ./clean.bash --env field/robot/planning-pc $STOP_ARGS
      
      ####################################################
      # delete docker images & corresponding containers
      ####################################################
      - delete:
        - 'export DELETE_ARGS="--containers" '
        - ./clean.bash --env field/robot/planning-pc $DELETE_ARGS
        - ./clean.bash --env local/subt/ros $DELETE_ARGS
        - ./clean.bash --env local/osrf/osrf $DELETE_ARGS
        - ./clean.bash --env local/osrf/ros $DELETE_ARGS
      
      ####################################################
      # misc.
      ####################################################
      - dangling:
        - docker rmi -f $(docker images -f "dangling=true" -q)
      
    ################################################################################################
    - deploy:
    ################################################################################################
      - +ssh:{ robot:planning-pc:/home/$USER/.ssh/deploy }
      - +docker:subt
      
      - hostname
      - whoami
      - pwd
      - 'export DEPLOY_SRC=/home/developer/deploy_ws/src'
      - 'export DEPLOY_WS=/home/developer/deploy_ws/'
      - cd $DEPLOY_SRC
  
      ####################################################
      # clone workspaces
      ####################################################
      - clone:

        # download the subt_robot_examples_latest
        # NOTE: only do this on ONCE. requires internet access.
        - download:
          - if [ -f subt_robot_examples_latest.tgz ]; then
              rm subt_robot_examples_latest.tgz;
            fi
          - wget --no-check-certificate https://s3.amazonaws.com/osrf-distributions/subt_robot_examples/releases/subt_robot_examples_latest.tgz

        # clone & update the planning workspace
        - cd planning/
        
        # setup the rosinstalls
        - rosinstall:
          - planning:
            - thirdparty:
              - cd thirdparty/catkin
              - if [ -f .rosinstall ]; then
                  rm .rosinstall;
                fi
              - ln -s $DEPLOY_SRC/rosinstall/planning/thirdparty.rosinstall .rosinstall
            - repo:
              - if [ -f .rosinstall ]; then
                  rm .rosinstall;
                fi
              - ln -s $DEPLOY_SRC/rosinstall/planning/planning.rosinstall .rosinstall
            - hardware:
              - cd hardware/catkin
              - if [ -f .rosinstall ]; then
                  rm .rosinstall;
                fi
              - ln -s $DEPLOY_SRC/rosinstall/planning/hardware.rosinstall .rosinstall

        # wstool update the workspaces
        - up:
          - planning:
            - thirdparty:
              - cd thirdparty/catkin
              - wstool info
              - wstool update
            - repo:
              - wstool info
              - wstool update
            - hardware:
              - cd hardware/catkin
              - wstool info
              - wstool update

      ####################################################
      # rosdep
      # -- assumes the extended ws are already built
      # -- add only those repos that need rosdep
      ####################################################
      - rosdep:
        # install any thirdparty deps
        - cd planning
        - planning:
          - ./Planning_workspace/install_dependencies.sh

      ####################################################
      # build workspaces
      ####################################################
      - build:
        - planning:
          - cd planning/

          # build the hardware workspace
          - thirdparty:
            - cd thirdparty/catkin
            - catkin build --force-cmake

          # build planning workspace
          - repo:
            - catkin build --force-cmake

          # build the hardware workspace
          - hardware:
            - cd hardware/catkin
            - catkin build --force-cmake

          # build launch workspace
          - launch:
            - cd $DEPLOY_SRC/launch/
            - catkin profile set planning
            - catkin clean -b --yes
            - catkin build --force-cmake

      ####################################################
      # clean workspaces
      ####################################################
      - clean:
        - launch:
          - cd $DEPLOY_SRC/launch/
          - catkin clean -y
        - planning:
          - cd $DEPLOY_SRC/planning/
          - hardware:
            - cd hardware/catkin
            - catkin clean -y
          - repo:
            - catkin clean -y
          - thirdparty:
            - cd thirdparty/catkin
            - catkin clean -y

      ####################################################
      # remove workspaces
      ####################################################
      - rm:
        - planning:
          - cd planning/
          - repo:
            - find . -maxdepth 1 \! \( -name thirdparty -o -name hardware -o -name .catkin_tools \) -exec rm -rf '{}' \;
          - hardware:
            - cd hardware/catkin
            - find . -maxdepth 1 \! \( -name .catkin_tools \) -exec rm -rf '{}' \;
          - thirdparty:
            - cd thirdparty/catkin
            - find . -maxdepth 1 \! \( -name .catkin_tools \) -exec rm -rf '{}' \;

      ####################################################
      # launch workspaces
      ####################################################
      - launch:
        ### == user can modify ==
        
        # launch configuration variables
        - 'export host=$(hostname)'
        - 'export MCAST_GROUP=224.0.0.251'
        - 'export USER=developer'
        - 'export ROS_MASTER_URI=http://planning-pc:11311'
        - 'export ROS_HOSTNAME=$(hostname)'

        ### == user can modify done. ==

        # create the bag folder
        - mkdir -p $DEPLOY_SRC/launch/ugv_setup/logging/planning-pc/bags/

        # get launch configuration data
        - export CONFIG_PATH="$DEPLOY_SRC/launch/robot_launch_scripting/config/"
        # parse config file for roslaunch params
        - get_config_data() {
            CONFIG_FILE=$CONFIG_PATH/${1}.config;
            while IFS='' read -r line || [[ -n "$line" ]]; do
              if [ ! "${line:0:1}" == "#" ]; then
                config_data="$config_data $line ";
              fi
            done < "$CONFIG_FILE";
            echo ${config_data};
          }
        - export -f get_config_data

        - start:
          - roscore:
            # enable roscore
            - 'export ROS_MASTER=true'
            # start the tmux sessions
            - tmux new -s ${host}_roscore -d
            # source
            - tmux send -t ${host}_roscore 'source $DEPLOY_WS/devel/planning/launch/setup.bash' ENTER
            # run roscore
            - tmux send -t ${host}_roscore 'rosrun robot_launch_scripting launch_roscore.sh' ENTER
          
          - planning:
            # parse the launch configuration params
            - export config=robots/r1/planning-pc/planning
            - export config_data=$(get_config_data "$config")

            # start the tmux session
            - tmux new -s launch_planning -d
            # source
            - tmux send -t launch_planning 'source $DEPLOY_WS/devel/planning/launch/setup.bash' ENTER

            # manually set the tmux env vars...for now.
            - tmux send -t launch_planning 'unset config_data' ENTER
            - tmux send -t launch_planning 'export config=robots/r1/planning-pc/planning' ENTER
            - tmux send -t launch_planning 'export config_data=$(get_config_data "$config")' ENTER

            # run autonomy launch
            - tmux send -t launch_planning 'mon launch robot_launch_scripting subt.launch $config_data' ENTER
            # message user
            - echo "Launch deployed in tmux session launch_planning"
          
          - hardware:
            # parse the launch configuration params
            - export config=robots/r1/planning-pc/hardware
            - export config_data=$(get_config_data "$config")

            # start the tmux session
            - tmux new -s launch_hardware -d
            # source
            - tmux send -t launch_hardware 'source $DEPLOY_WS/devel/planning/launch/setup.bash' ENTER

            # manually set the tmux env vars...for now.
            - tmux send -t launch_hardware 'unset config_data' ENTER
            - tmux send -t launch_hardware 'export config=robots/r1/planning-pc/hardware' ENTER
            - tmux send -t launch_hardware 'export config_data=$(get_config_data "$config")' ENTER

            # run hardware launch
            - tmux send -t launch_hardware 'mon launch robot_launch_scripting subt.launch $config_data' ENTER
            # message user
            - echo "Launch deployed in tmux session launch_hardware"
          
          - shell:
            # empty shell prompt
            - pwd
            - tmux new -s ros_shell -d
            - tmux send -t ros_shell 'source $DEPLOY_WS/devel/planning/launch/setup.bash' ENTER

          - rosbag:
            # start record hardware
            - tmux new -s launch_rosbag -d
            # source
            - tmux send -t launch_rosbag 'source $DEPLOY_WS/devel/planning/launch/setup.bash' ENTER
            # manually set the tmux env vars...for now.
            - tmux send -t launch_rosbag 'unset config_data' ENTER
            - tmux send -t launch_rosbag 'export config=robots/r1/planning-pc/rosbag' ENTER
            - tmux send -t launch_rosbag 'export config_data=$(get_config_data "$config")' ENTER
            # launch rosbag
            - tmux send -t launch_rosbag 'eval $config_data' ENTER
          # old rosbag that uses 'recorder'. cant use that, since recorder does not have the option to split
          # - rosbag:
          #   - recorder:
          #     # start the recorder tmux session
          #     - tmux new -s launch_rosbag_recorder -d
          #     # source
          #     - tmux send -t launch_rosbag_recorder 'source $DEPLOY_WS/devel/planning/launch/setup.bash' ENTER
          #     # manually set the tmux env vars...for now.
          #     - tmux send -t launch_rosbag_recorder 'unset config_data' ENTER
          #     - tmux send -t launch_rosbag_recorder 'export config=robots/r1/planning-pc/recorder' ENTER
          #     - tmux send -t launch_rosbag_recorder 'export config_data=$(get_config_data "$config")' ENTER
          #     # launch recorder
          #     - tmux send -t launch_rosbag_recorder 'mon launch robot_launch_scripting subt.launch computer:=planning-pc robot:=robots/logging $config_data' ENTER
          #   - bag:
          #     # start record hardware
          #     - tmux new -s launch_rosbag_start -d
          #     # source
          #     - tmux send -t launch_rosbag_start 'source $DEPLOY_WS/devel/planning/launch/setup.bash' ENTER
          #     # manually set the tmux env vars...for now.
          #     - tmux send -t launch_rosbag_start 'unset config_data' ENTER
          #     - tmux send -t launch_rosbag_start 'export config=robots/r1/planning-pc/rosbag_start' ENTER
          #     - tmux send -t launch_rosbag_start 'export config_data=$(get_config_data "$config")' ENTER
          #     # launch rosbag
          #     - tmux send -t launch_rosbag_start 'roslaunch robot_launch_scripting subt.launch computer:=planning-pc robot:=robots/logging $config_data' ENTER
          #   # message user
          #   - echo "Launch deployed in tmux session launch_rosbag"

        - stop:
          # remove all the tmux sessions
          - rosbag:
              - stop:
                # start stop record
                - tmux new -s launch_rosbag_stop -d
                - tmux send -t launch_rosbag_stop 'source $DEPLOY_WS/devel/planning/launch/setup.bash' ENTER  
                # stop record node
                - tmux send -t launch_rosbag_stop 'rosnode kill /rosbag_recording_planning_pc' ENTER
              - sessions:
                # stop the sessions
                # - until rostopic list ; do sleep 1; done
                - tmux kill-session -t launch_rosbag_stop
                - tmux kill-session -t launch_rosbag
          - roscore:
            - tmux kill-session -t ${host}_roscore
          - planning:
            - tmux kill-session -t launch_planning
          - hardware:
            - tmux kill-session -t launch_hardware
          - shell:
            - tmux kill-session -t ros_shell
            # old rosbag that uses 'recorder'. cant use that, since recorder does not have the option to split
            # - stop:
            #   # start record hardware
            #   - tmux new -s launch_rosbag_stop -d
            #   # source
            #   - tmux send -t launch_rosbag_stop 'source $DEPLOY_WS/devel/planning/launch/setup.bash' ENTER  
            #   # manually set the tmux env vars...for now.
            #   - tmux send -t launch_rosbag_stop 'unset config_data' ENTER
            #   - tmux send -t launch_rosbag_stop 'export config=robots/r1/planning-pc/rosbag_stop' ENTER
            #   - tmux send -t launch_rosbag_stop 'export config_data=$(get_config_data "$config")' ENTER
            #   # launch rosbag
            #   - tmux send -t launch_rosbag_stop 'roslaunch robot_launch_scripting subt.launch computer:=planning-pc robot:=robots/logging $config_data' ENTER
            #   - tmux kill-session -t launch_rosbag_stop
            # - recorder:
            #   - tmux kill-session -t launch_rosbag_recorder
            # - bag:
            #   - tmux kill-session -t launch_rosbag_start
          
        - rosclean:
          # stop all ros nodes
          - source $DEPLOY_WS/devel/planning/repo/setup.bash
          - ps aux | grep ros
          - rosnode kill -a
          - pkill -f ros
          - rosnode list
          - ps aux | grep ros
        
      ####################################################
      # git updater
      ####################################################
      - git:
        - 'export DEPLOY_WS=/home/$(whoami)/deploy_ws/'
        - 'export DEPLOY_SRC=$DEPLOY_WS/src'
        
        # git status check          
        - git_status() {
            for repo in $1; do
              pushd $repo  > /dev/null 2>&1;
              if [ -d .git ]; then
                echo -e "\n${YELLOW}\trepo -> \t $(basename $repo) \n ${RESET}" ;
                git config --get remote.origin.url;
                git status;
                echo -e "\n\n";
              fi;
              popd  > /dev/null 2>&1;
            done;
          }
        - export -f git_status

        # git status check          
        - git_dirty() {
            for repo in $1; do
              pushd $repo  > /dev/null 2>&1;
              if [ -d .git ]; then
                if [[ $(git status -s) ]]; then
                  echo -e "\n${YELLOW}\trepo -> \t $(basename $repo) \n ${RESET}" ;
                  git config --get remote.origin.url;
                  git status;
                  echo -e "\n\n";
                fi;
              fi;
              popd  > /dev/null 2>&1;
            done;
          }
        - export -f git_dirty

        # wstool update to git hash
        - git_updater() {
            for repo in $1; do
              echo "repo is $repo";
              pushd $repo  > /dev/null 2>&1;
              if [ -d .git ]; then
                echo -e "\n${YELLOW}\trepo -> \t $(basename $repo) \n ${RESET}" ;
                export GIT_COMMIT_HASH=$(git rev-parse --verify HEAD);
                export ROSINSTALL_GIT_HASH=$(wstool info $(basename $repo) --yaml | grep -oP "version\K.*" | grep -oP " \K.*");
                wstool set $(basename $repo) -v $GIT_COMMIT_HASH -y;
                echo -e "\n\n";
              fi;
              popd  > /dev/null 2>&1;
            done;
          }
        - export -f git_updater

        ####################################################
        # git commands for planning workspace
        ####################################################
        - planning:
          - cd $DEPLOY_SRC/planning

           git update to thirdparty ws
          - thirdparty:
            - status:
              - 'export git_fn=git_status'
            - update:
              - 'export git_fn=git_updater'
            - dirty:
              - 'export git_fn=git_dirty'
            # execute git fn            
            - cd thirdparty/catkin
            - export REPOS=$(find . -maxdepth 1 \! \( -name .catkin_tools -o -name .rosinstall \) )
            - $git_fn "$REPOS"

          # git update to repo ws
          - repo:
            - status:
              - 'export git_fn=git_status'
            - update:
              - 'export git_fn=git_updater'
            - dirty:
              - 'export git_fn=git_dirty'
            # execute git fn
            - export REPOS=$(find . -maxdepth 1 \! \( -name thirdparty -o -name hardware -o -name .catkin_tools -o -name .rosinstall \) )
            - $git_fn "$REPOS"


